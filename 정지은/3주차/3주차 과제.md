### 기본 충돌 사용

기본적으로 코드에서 메소드 사용의 효율성을 강조한다.
object에 colider를 넣고 움직이는 플레이어에 rigid body를 만들어서 똑바로 움직이게 할 수 있다.
(공중에 떠오르거나 회전하지 않게 rotation, position y축 고정, gravity 사용 x)

---

### Trigger

Trigger를 사용하면 collider는 있지만 플레이어가 지나가면서 부딪히지 않게 할 수 있다. 대신 어떤 설정을 발생시킨다. (비디오게임에서 많이 사용하는 방법)

---

### 충돌 메시지 출력

`collapse`를 눌러서 메시지를 매번 출력하지 않고 숫자만 표시하는 축소 표시가 가능하다.
적용 예시: 점수, 상태, Hit point

-   **충돌했을 때 벽 색깔 바뀌게 하기**
    -   `ObjectHit.cs` 스크립트의 `OnCollisionEnter` 안에 아래 코드를 추가한다.
    -   `GetComponent<MeshRenderer>().material.color = Color.red;`

-   **부딪힌 횟수 출력**
    -   `Score.cs` 파일을 새로 만들어서 아래 내용을 추가한다.

    ```csharp
    using UnityEngine;

    public class Scorer : MonoBehaviour
    {
        int hits = 0;
        private void OnCollisionEnter(Collision other)
        {
            hits++;
            Debug.Log("You've bumped into a thing this many times: " + hits);
        }
    }
    ```

---

### 캐싱(Caching)

자주 사용되는 데이터나 정보를 메모리에 저장하여 필요할 때 쉽게 접근할 수 있게 해준다.

---

### 태그

회전: `transform.Rotate(xAngle, yAngle, zAngle);`

---

### 플레이어에 비행, 객체 파괴, 트리거 볼륨

플레이어가 트리거 볼륨을 지나면 → 객체가 플레이어로 비행 → 목표 지점 도달 후 파괴

-   **플레이어에 대한 참조 만들기**
    -   코드, 유니티에서 플레이어 참조

-   **객체 파괴 (ex. 총알, 대포)**
    -   목표 지점에 도달하면 객체가 파괴되도록 한다.

    ```csharp
    public class FlyAtPlayer : MonoBehaviour
    {
        [SerializeField] float speed = 0.1f;
        [SerializeField] Transform player;
        Vector3 playerPosition;

        void Start()
        {
            playerPosition = player.transform.position;
        }

        void Update()
        {
            MoveToPlayer();
            DestroyWhenReached();
        }

        void MoveToPlayer()
        {
            // MoveTowards(현재위치, 목표위치, 속도) ; 플레이어가 있는 곳으로 1 유닛씩 이동
            transform.position =
            Vector3.MoveTowards(transform.position, playerPosition, Time.deltaTime * speed);
        }

        void DestroyWhenReached()
        {
            if (transform.position == playerPosition)
            {
                Destroy(gameObject);
            }
        }
    }
    ```

---

### 트리거 볼륨 활성화

트리거 볼륨이 될 큐브를 만들고 projectile을 연결한다.

-   **코드 (비효율적인 기본 버전)**

    ```csharp
    public class TriggerProjectile : MonoBehaviour
    {
        [SerializeField] GameObject projectile1;
        [SerializeField] GameObject projectile2;
        [SerializeField] GameObject projectile3;
        [SerializeField] GameObject projectile4;
        [SerializeField] GameObject projectile5;

        private void OnTriggerEnter(Collider other)
        {
            if(other.gameObject.tag == "Player")
            {
                projectile1.SetActive(true);
                projectile2.SetActive(true);
                projectile3.SetActive(true);
                projectile4.SetActive(true);
                projectile5.SetActive(true);
            }
        }
    }
    ```

-   **트리거/충돌 문제에서 중요한 확인사항**
    -   Is Trigger가 켜져 있어야 함
    -   플레이어에게 Rigidbody가 있어야 함

---

### 프리팹(Prefab)

유니티에서 중요한 요소이다. 하드 드라이브에 저장된다.
-   일반적 규칙: 프리팹으로 만들 수 있는 건 모두 프리팹으로 만들기
-   그룹화 같은 것. 크기, 재질 등 변경사항 모두 한 번에 적용 가능하다.
-   플레이어를 프리팹으로 만드는 것이 중요하다.

---

### Awake 콜백 사용, 오류 해결

---

### 레벨 레이아웃

레벨 디자인 후 위험 요소를 추가하였다.


---

### 오류 해결

강의대로 코드를 작성하니 플레이어가 트리거 볼륨을 지나도 projectile이 날아오지 않는 오류가 발생하였다. 처음부터 projectile을 비활성화해두고 트리거 볼륨을 지날 시 활성화가 되는 코드를 작성하였다. 오류 원인을 분석해보니 `FlyAtPlayer.cs` 파일의 아래 구문 때문에 계속 projectile이 비활성화 상태로 유지되고 있었다.

```csharp
void Awake()
{
    gameObject.SetActive(false);
}
```
해당 구문을 주석 처리하니 플레이어가 트리거 볼륨을 통과한 위치로 projectile이 날아와 ground에 닿으면 최종적으로 파괴되었다. 아마 prefab으로 옮기면서 충돌이 있었던 것 같다. 코드의 여러 부분을 주석 처리 해보고 수정해본 끝에 성공적으로 원인을 찾아서 오류를 해결했다.
